{
  "name": "Bulk Submit Prompt",
  "version": "1.0",
  "description": "Instructions and a script template to bulk-rename folders under 3dProject_to_add, translate non-English names to English, convert to CamelCase, then submit each item with recipient 'Bulk_Import' and import contents into app_home/projects. DO NOT EXECUTE. This file is a prompt/template only.",
  "sourceDirectory": "3dProject_to_add",
  "targetDirectory": "app_home/projects",
  "submission": {
    "recipient": "Ryan Hunsaker",
    "importEndpoint": "http://localhost:8080/api/import (placeholder - replace with your project's import endpoint or CLI)",
    "notes": "The import step should use the project's normal import mechanism. This template includes a HTTP POST option and a local copy option; adapt as needed.",
    "doNotExecute": true
  },
  "projectType": "Prototype",
  "database": {
    "note": "This project uses an H2 database. Use Database.java to determine the correct endpoints and connection details for submitting metadata/files to the database.",
    "useClass": "Locate and call the project's Database.java class (e.g., src/main/java/**/Database.java) to obtain JDBC URL, REST endpoints or submission helpers.",
    "dbType": "H2",
    "deriveEndpoints": true,
    "caveat": "Template scripts must NOT hard-code DB credentials. Read configuration from the same source Database.java uses (properties, env vars, or config files)."
  },
  "duplicateHandling": {
    "strategy": "skip_identical_keep_existing",
    "detection": "Compare files by SHA256 digest and/or exact filename + size + checksum. If a folder contains items identical to previously uploaded items, skip those items and prefer the existing uploaded copy.",
    "note": "If item metadata differs but file content is identical, still skip the content upload but optionally update metadata if your import API supports metadata-only updates."
  },
  "logging": {
    "enabled": true,
    "logFile": "3dProject_to_add/upload.log",
    "logLevel": "info",
    "whatToLog": "All operations: detection, translation, rename suggestions, skip decisions, copy actions, POST requests, errors and warnings. Include timestamps and original paths."
  },
  "renameRules": {
    "removeSpaces": true,
    "stripExtraCharacters": "Remove characters that are not letters, numbers, spaces, dashes or underscores",
    "translation": "Detect language; if not English, translate the folder name to English before converting to CamelCase",
    "casing": "PascalCase (CamelCase with initial capital) for folder names",
    "examples": {
      "\u2018My Project Folder\u2019": "MyProjectFolder",
      "\u2018projet-imprimante 3D\u2019 -> translate -> '3D printer project' -> '3DPrinterProject'": "3DPrinterProject"
    }
  },
  "scriptTemplate": {
    "language": "nodejs",
    "filenameSuggestion": "bulk_import_template.js",
    "dependencies": [
      "fs (built-in)",
      "path (built-in)",
      "axios (optional, for HTTP POST)",
      "camelcase (npm package)",
      "franc (npm package, optional language detection)",
      "@vitalets/google-translate-api (optional, for translation)"
    ],
    "purpose": "Template that demonstrates detecting/ translating folder names, renaming them to PascalCase, copying contents into the target import folder, and posting metadata/files to an import endpoint with recipient 'Bulk_Import'.",
    "note": "This is a template — inspect and adapt to your project's specific import mechanism and security requirements. The template defaults to dry-run and non-destructive behavior. Do not run without reviewing.",
  ,
    "scriptLines": [
      "#!/usr/bin/env node",
      "// bulk_import_secure_template.js - secure template (dry-run default). Review before executing.",
      "const fs = require('fs');",
      "const path = require('path');",
      "const crypto = require('crypto');",
      "const child_process = require('child_process');",
      "const os = require('os');",
      "let axios; try { axios = require('axios'); } catch (e) { axios = null; }",
      "const camelCase = (() => { try { return require('camelcase'); } catch (e) { return s => s.replace(/[^a-zA-Z0-9]/g, ' ').split(/\\s+/).map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(''); } })();",
      "const franc = (() => { try { return require('franc'); } catch (e) { return null; } })();",
      "const translate = (() => { try { return require('@vitalets/google-translate-api'); } catch (e) { return null; } })();",
      "const SRC_DIR = path.resolve(__dirname, '3dProject_to_add');",
      "const TARGET_DIR = path.resolve(__dirname, 'app_home', 'projects');",
      "const LOG_FILE = path.join(SRC_DIR, 'upload.log');",
      "const INDEX_FILE = path.join(TARGET_DIR, '.upload_index.json');",
      "const IMPORT_URL = process.env.IMPORT_URL || 'http://localhost:8080/api/import';",
      "const DRY_RUN = true; // change to false only after careful review",
      "function log(level, msg) {",
      "  const line = new Date().toISOString() + ' [' + level.toUpperCase() + '] ' + msg + '\n';",
      "  try { fs.appendFileSync(LOG_FILE, line); } catch (e) { console.error('Failed to write log:', e && e.message); }",
      "  console.log(line.trim());",
      "}",
      "function sha256File(p) {",
      "  const data = fs.readFileSync(p);",
      "  return crypto.createHash('sha256').update(data).digest('hex');",
      "}",
      "function dirContentChecksum(dir) {",
      "  // Compute checksums for all files in dir, produce a combined hash",
      "  const list = [];
      "  (function walk(d) {
      "    for (const it of fs.readdirSync(d, { withFileTypes: true })) {
      "      const p = path.join(d, it.name);
      "      if (it.isFile()) list.push({ p: path.relative(dir, p), h: sha256File(p) });
      "      else if (it.isDirectory()) walk(p);
      "    }
      "  })(dir);
      "  list.sort((a,b)=>a.p.localeCompare(b.p));
      "  const combined = list.map(x=>x.p+":"+x.h).join('|');
      "  return crypto.createHash('sha256').update(combined).digest('hex');",
      "}",
      "function loadIndex() {",
      "  try { return JSON.parse(fs.readFileSync(INDEX_FILE, 'utf8')); } catch (e) { return {}; }",
      "}",
      "function saveIndex(idx) {",
      "  try { fs.mkdirSync(path.dirname(INDEX_FILE), { recursive: true }); fs.writeFileSync(INDEX_FILE, JSON.stringify(idx, null, 2)); } catch (e) { log('error', 'Failed to save index: '+(e && e.message)); }",
      "}",
      "function getDBEndpointsViaJava() {",
      "  // Attempt to call Database.java helper to print endpoints. Adjust classpath and class name to your project.",
      "  try {",
      "    // Example: `java -cp build/classes/java/main:lib/* com.example.Database --print-endpoints`",
      "    const cp = process.env.JAVA_CLASSPATH || 'build/classes/java/main:lib/*';",
      "    const classname = process.env.DATABASE_CLASS || 'com.example.Database';",
      "    const out = child_process.spawnSync('java', ['-cp', cp, classname, '--print-endpoints'], { encoding: 'utf8', timeout: 20000 });",
      "    if (out.error) { log('warn', 'Java execution failed: '+out.error.message); return null; }",
      "    if (out.status !== 0) { log('warn', 'Java helper returned non-zero status. stdout: '+out.stdout+' stderr: '+out.stderr); return null; }",
      "    try { return JSON.parse(out.stdout); } catch (e) { log('warn', 'Could not parse endpoints JSON from Database.java output'); return { raw: out.stdout }; }",
      "  } catch (e) { log('warn', 'Java interop skipped: '+(e && e.message)); return null; }",
      "}",
      "function safeCopyDir(src, dst) {",
      "  fs.mkdirSync(dst, { recursive: true });",
      "  for (const it of fs.readdirSync(src, { withFileTypes: true })) {",
      "    const s = path.join(src, it.name); const d = path.join(dst, it.name);",
      "    if (it.isDirectory()) safeCopyDir(s, d); else fs.copyFileSync(s, d);",
      "  }",
      "}",
      "async function submitTempDir(tempDir, metadata) {",
      "  // Prefer calling Database.java submit helper or project's import CLI for safe insertion into H2.",
      "  const javaHelper = process.env.DATABASE_CLASS || 'com.example.Database';",
      "  const cp = process.env.JAVA_CLASSPATH || 'build/classes/java/main:lib/*';",
      "  try {",
      "    // If the project provides a helper that can accept a folder path, call it safely.",
      "    const out = child_process.spawnSync('java', ['-cp', cp, javaHelper, '--import-folder', tempDir, '--recipient', 'Ryan Hunsaker', '--projectType', 'Prototype'], { encoding: 'utf8', timeout: 120000 });",
      "    log('info', 'Java import helper stdout: '+(out.stdout||'') );",
      "    if (out.status !== 0) { log('error', 'Java import helper failed: '+(out.stderr||'exit '+out.status)); return false; }",
      "    return true;",
      "  } catch (e) {",
      "    log('warn', 'Java submit attempt failed: '+(e && e.message));",
      "  }",
      "  // Fallback: HTTP POST metadata only (not file contents). Real import may need multipart uploads.",
      "  if (axios) {",
      "    try {",
      "      await axios.post(IMPORT_URL, metadata, { timeout: 120000 });",
      "      return true;",
      "    } catch (e) { log('warn', 'HTTP POST failed: '+(e && e.message)); }",
      "  } else log('info', 'Axios not available; skipped HTTP POST');",
      "  return false;",
      "}",
      "async function processFolder(dirEntry) {",
      "  const originalName = dirEntry;",
      "  const originalPath = path.join(SRC_DIR, originalName);",
      "  log('info', 'Processing: '+originalPath);",
      "  const checksum = dirContentChecksum(originalPath);",
      "  const idx = loadIndex();",
      "  if (idx[checksum]) {",
      "    log('info', 'Duplicate detected; skipping upload for '+originalName+' (keeps existing)');",
      "    return;",
      "  }
      "  // detect/translate and make safe PascalCase name
      "  let translated = originalName;",
      "  try { if (franc) { const lang = franc(originalName, { minLength: 1 }); if (lang && lang !== 'eng' && lang !== 'und' && translate) { const res = await translate(originalName, { to: 'en' }); translated = res && res.text ? res.text : originalName; } } } catch (e) { log('warn', 'Translation failed: '+(e && e.message)); }",
      "  const newName = camelCase(translated.replace(/[^\\p{L}\\p{N}]+/gu, ' '), { pascalCase: true });",
      "  log('info', `Rename suggestion: ${originalName} -> ${newName}`);",
      "  const tempBase = fs.mkdtempSync(path.join(os.tmpdir(), 'bulk-import-'));",
      "  const tempDir = path.join(tempBase, newName);",
      "  safeCopyDir(originalPath, tempDir);",
      "  log('info', 'Copied to temp dir: '+tempDir);",
      "  const metadata = { recipient: 'Ryan Hunsaker', projectType: 'Prototype', originalName, folderName: newName, checksum };",
      "  if (DRY_RUN) { log('info', 'Dry-run enabled — skipping actual submission for '+newName); log('info', 'Would submit metadata: '+JSON.stringify(metadata)); fs.rmSync(tempBase, { recursive: true, force: true }); return; }",
      "  const ok = await submitTempDir(tempDir, metadata);",
      "  if (ok) {",
      "    idx[checksum] = { originalName, folderName: newName, uploadedAt: new Date().toISOString() };",
      "    saveIndex(idx);",
      "    // Move to final target atomically",
      "    const finalPath = path.join(TARGET_DIR, newName);",
      "    if (!fs.existsSync(finalPath)) fs.mkdirSync(finalPath, { recursive: true });",
      "    // Move temp contents to final (non-destructive if already exists)",
      "    safeCopyDir(tempDir, finalPath);",
      "    log('info', 'Import succeeded and files placed in: '+finalPath);",
      "  } else {",
      "    log('error', 'Submission failed for '+newName);",
      "  }",
      "  fs.rmSync(tempBase, { recursive: true, force: true });",
      "}",
      "async function main() {",
      "  log('info', 'Template started (dry-run='+DRY_RUN+')');",
      "  if (!fs.existsSync(SRC_DIR)) { log('error', 'Source directory missing: '+SRC_DIR); return; }",
      "  fs.mkdirSync(path.dirname(LOG_FILE), { recursive: true });",
      "  const endpoints = getDBEndpointsViaJava();",
      "  if (endpoints) log('info', 'Discovered endpoints via Database.java: '+JSON.stringify(endpoints));",
      "  const entries = fs.readdirSync(SRC_DIR, { withFileTypes: true });",
      "  for (const e of entries) { if (!e.isDirectory()) continue; await processFolder(e.name); }",
      "  log('info', 'Template finished. Review upload.log and .upload_index.json for results.');",
      "}",
      "// Do not call main automatically. Export for controlled invocation after review.",
      "module.exports = { main, processFolder, dirContentChecksum, getDBEndpointsViaJava };"
    ]
  },
  "usageGuidance": [
    "1) Review the template in scriptTemplate.scriptLines and adapt the import endpoint or local CLI call used by your project.",
    "2) Install required npm packages if you plan to use the HTTP/translation features: `npm install axios camelcase franc @vitalets/google-translate-api`",
    "3) Test the script on a small sample folder, with dry-run behavior (do not rename or overwrite) before bulk-running.",
    "4) The template marks destructive operations (rename, copy) as commented — enable them only after review.",
    "5) When ready, run the script from the repository root or adapt paths to your environment.",
    "6) If your project has a specific 'normal import' CLI or API, replace the POST-copy placeholder with calls to that mechanism and include authentication tokens as required."
  ],
  "finalNote": "This JSON file is a prompt and code template only. DO NOT EXECUTE anything until you have reviewed and adapted the template to your environment."
}